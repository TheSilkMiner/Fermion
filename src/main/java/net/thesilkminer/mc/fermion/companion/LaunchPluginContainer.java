package net.thesilkminer.mc.fermion.companion;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.eventbus.EventBus;
import net.minecraftforge.fml.common.DummyModContainer;
import net.minecraftforge.fml.common.LoadController;
import net.minecraftforge.fml.common.ModMetadata;
import net.thesilkminer.mc.fermion.asm.api.PluginMetadata;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import javax.annotation.Nonnull;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public final class LaunchPluginContainer extends DummyModContainer {

    private static final Logger LOGGER = LogManager.getLogger("LaunchPluginContainer");

    private final List<String> ownedPackages;

    public LaunchPluginContainer(@Nonnull final PluginMetadata metadata, @Nonnull final List<String> ownedPackages) {
        super(cast(metadata));
        this.ownedPackages = ImmutableList.copyOf(ownedPackages);
        LOGGER.info("Generated container '" + this + "'");
    }

    @Nonnull
    private static ModMetadata cast(@Nonnull final PluginMetadata metadata) {
        LOGGER.debug("Attempting to cast to ModMetadata the plugin metadata: " + metadata);

        final ModMetadata instance = new ModMetadata();
        instance.authorList = cast(metadata.getAuthors());
        instance.autogenerated = false;
        if (metadata.getCredits() != null) instance.credits = metadata.getCredits();
        instance.description = buildAdvancedDescriptions(metadata);
        if (metadata.getLogo() != null) instance.logoFile = metadata.getLogo();
        instance.modId = metadata.getId();
        instance.name = metadata.getName();
        if (metadata.getUrl() != null) instance.url = metadata.getUrl();
        instance.version = metadata.getVersion().toString();
        return instance;
    }

    @Nonnull
    private static List<String> cast(@Nonnull final List<PluginMetadata.Author> authors) {
        return authors.stream().map(PluginMetadata.Author::getName).collect(Collectors.toList());
    }

    @Nonnull
    private static String buildAdvancedDescriptions(@Nonnull final PluginMetadata metadata) {
        final StringBuilder builder = new StringBuilder();
        if (metadata.getDescription() != null) builder.append(metadata.getDescription());

        final Map<String, Boolean> thisPluginTransformersMap = getTransformersMap().entrySet().stream()
                .filter(it -> it.getKey().startsWith(metadata.getId() + ":"))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
        final List<String> enabled = thisPluginTransformersMap.entrySet().stream()
                .filter(Map.Entry::getValue)
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());
        final List<String> disabled = thisPluginTransformersMap.entrySet().stream()
                .filter(it -> !it.getValue())
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());

        if (!enabled.isEmpty()) {
            builder.append("\n\n\nEnabled transformers:\n");
            enabled.forEach(it -> {
                builder.append("- ");
                builder.append(it);
                builder.append('\n');
            });
        }

        if (!disabled.isEmpty()) {
            builder.append("\n\n\nDisabled transformers:\n");
            disabled.forEach(it -> {
                builder.append("- ");
                builder.append(it);
                builder.append('\n');
            });
        }

        final String desc = builder.toString();
        LOGGER.debug("Successfully generated description for plugin: '" + desc + "'");
        return desc;
    }

    @Nonnull
    private static Map<String, Boolean> getTransformersMap() {
        LOGGER.error("To be filled with ASM");
        return ImmutableMap.of();
    }

    @Override
    public boolean registerBus(@Nonnull @SuppressWarnings("UnstableApiUsage") final EventBus bus, @Nonnull final LoadController controller) {
        return true;
    }

    @Override
    public List<String> getOwnedPackages() {
        return this.ownedPackages;
    }
}
